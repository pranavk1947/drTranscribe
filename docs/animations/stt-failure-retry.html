<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STT Failure &amp; Retry Pipeline -- Animated Dataflow</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: #0f172a;
    color: #e2e8f0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 28px 16px 56px;
    overflow-x: hidden;
  }

  h1 {
    font-size: 1.6rem;
    font-weight: 800;
    letter-spacing: -0.03em;
    margin-bottom: 2px;
    color: #f8fafc;
  }

  .subtitle {
    font-size: 0.85rem;
    color: #64748b;
    margin-bottom: 24px;
    letter-spacing: 0.01em;
  }

  /* ---- SVG canvas ---- */
  .svg-wrap {
    width: 100%;
    max-width: 1120px;
    border: 1px solid #1e293b;
    border-radius: 16px;
    background: linear-gradient(180deg, #0f172a 0%, #0c1322 100%);
    position: relative;
    overflow: visible;
    box-shadow: 0 4px 32px #0008;
  }

  svg { display: block; width: 100%; height: auto; }

  /* ---- Info panel ---- */
  .info-panel {
    width: 100%;
    max-width: 1120px;
    margin-top: 16px;
    padding: 22px 28px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 12px;
    min-height: 92px;
    transition: border-color 0.4s;
  }

  .info-panel .step-label {
    font-size: 0.7rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #475569;
    margin-bottom: 4px;
  }

  .info-panel .step-title {
    font-size: 1.2rem;
    font-weight: 800;
    color: #f1f5f9;
    margin-bottom: 8px;
  }

  .info-panel .step-desc {
    font-size: 0.88rem;
    line-height: 1.6;
    color: #94a3b8;
  }

  .info-panel .step-desc code {
    background: #334155;
    padding: 1px 6px;
    border-radius: 4px;
    font-size: 0.82rem;
    color: #e2e8f0;
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  }

  /* ---- Controls ---- */
  .controls {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 16px;
    width: 100%;
    max-width: 1120px;
    justify-content: center;
    flex-wrap: wrap;
  }

  .ctrl-btn {
    background: #1e293b;
    border: 1px solid #334155;
    color: #e2e8f0;
    border-radius: 8px;
    padding: 9px 20px;
    font-size: 0.82rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
    letter-spacing: 0.02em;
  }

  .ctrl-btn:hover { background: #334155; border-color: #475569; }
  .ctrl-btn:active { background: #475569; transform: scale(0.97); }
  .ctrl-btn.primary { background: #6366f1; border-color: #6366f1; color: #fff; }
  .ctrl-btn.primary:hover { background: #818cf8; border-color: #818cf8; }
  .ctrl-btn:disabled { opacity: 0.3; cursor: default; pointer-events: none; }

  .speed-select {
    background: #1e293b;
    border: 1px solid #334155;
    color: #e2e8f0;
    border-radius: 8px;
    padding: 9px 14px;
    font-size: 0.8rem;
    cursor: pointer;
    outline: none;
    font-weight: 600;
  }

  .speed-select:focus { border-color: #6366f1; }

  .step-counter {
    color: #64748b;
    font-size: 0.8rem;
    font-weight: 600;
    min-width: 70px;
    text-align: center;
    letter-spacing: 0.02em;
  }

  /* ---- Progress bar ---- */
  .progress-wrap {
    width: 100%;
    max-width: 1120px;
    margin-top: 14px;
    display: flex;
    gap: 3px;
  }

  .progress-pip {
    flex: 1;
    height: 4px;
    border-radius: 2px;
    background: #1e293b;
    transition: background 0.35s, box-shadow 0.35s;
    cursor: pointer;
  }

  .progress-pip:hover { background: #334155; }
  .progress-pip.done { background: #4f46e5; }
  .progress-pip.active { background: #a78bfa; box-shadow: 0 0 8px #a78bfa66; }

  /* ---- Failure banner ---- */
  .failure-banner {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: linear-gradient(135deg, #dc2626ee, #991b1bee);
    color: #fff;
    font-weight: 900;
    font-size: 1.15rem;
    padding: 12px 32px;
    border-radius: 12px;
    letter-spacing: 0.06em;
    pointer-events: none;
    transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.4s;
    opacity: 0;
    z-index: 10;
    white-space: nowrap;
    border: 2px solid #fca5a5;
    box-shadow: 0 0 40px #dc262666;
  }

  .failure-banner.visible {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }

  /* ---- Pulse keyframes for node glow ---- */
  @keyframes nodePulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
  }

  /* ---- Legend ---- */
  .legend {
    display: flex;
    gap: 20px;
    margin-top: 18px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.75rem;
    color: #64748b;
    font-weight: 600;
  }

  .legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    border: 2px solid;
  }
</style>
</head>
<body>

<h1>STT Failure &amp; Retry Pipeline</h1>
<p class="subtitle">Animated dataflow -- medical transcription resilience architecture</p>

<div class="svg-wrap" id="svgWrap">
  <div class="failure-banner" id="failBanner">ALL PROVIDERS FAILED</div>
  <svg id="mainSvg" viewBox="0 0 1080 580" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <marker id="arr" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto" markerUnits="strokeWidth">
        <path d="M0,0 L10,3.5 L0,7" fill="#334155" />
      </marker>
      <marker id="arr-hi" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto" markerUnits="strokeWidth">
        <path d="M0,0 L10,3.5 L0,7" fill="#818cf8" />
      </marker>
      <!-- glow for dots -->
      <filter id="dotGlow" x="-100%" y="-100%" width="300%" height="300%">
        <feGaussianBlur stdDeviation="4" result="g" />
        <feMerge><feMergeNode in="g" /><feMergeNode in="SourceGraphic" /></feMerge>
      </filter>
      <!-- subtle grid pattern -->
      <pattern id="grid" width="30" height="30" patternUnits="userSpaceOnUse">
        <path d="M30,0 L0,0 0,30" fill="none" stroke="#1e293b" stroke-width="0.5" opacity="0.5" />
      </pattern>
    </defs>

    <!-- background grid -->
    <rect width="1080" height="580" fill="url(#grid)" />

    <g id="edgesGroup"></g>
    <g id="nodesGroup"></g>
    <g id="dotsGroup"></g>
  </svg>
</div>

<div class="info-panel" id="infoPanel">
  <div class="step-label" id="stepLabel">Step 1 / 13</div>
  <div class="step-title" id="stepTitle">--</div>
  <div class="step-desc" id="stepDesc">--</div>
</div>

<div class="progress-wrap" id="progressWrap"></div>

<div class="controls">
  <button class="ctrl-btn" id="btnPrev" title="Previous step">Prev</button>
  <button class="ctrl-btn primary" id="btnPlay" title="Play / Pause">Pause</button>
  <button class="ctrl-btn" id="btnNext" title="Next step">Next</button>
  <span class="step-counter" id="stepCounter">1 / 13</span>
  <select class="speed-select" id="speedSelect" title="Animation speed">
    <option value="5000">Slow (5s)</option>
    <option value="3200" selected>Normal (3.2s)</option>
    <option value="1800">Fast (1.8s)</option>
    <option value="900">Turbo (0.9s)</option>
  </select>
</div>

<div class="legend">
  <div class="legend-item"><div class="legend-dot" style="background:#a78bfa44;border-color:#a78bfa"></div>WebSocket / Data</div>
  <div class="legend-item"><div class="legend-dot" style="background:#0ea5e944;border-color:#0ea5e9"></div>Primary STT</div>
  <div class="legend-item"><div class="legend-dot" style="background:#14b8a644;border-color:#14b8a6"></div>Fallback #1</div>
  <div class="legend-item"><div class="legend-dot" style="background:#f59e0b44;border-color:#f59e0b"></div>Fallback #2</div>
  <div class="legend-item"><div class="legend-dot" style="background:#ef444444;border-color:#ef4444"></div>DLQ / Failure</div>
  <div class="legend-item"><div class="legend-dot" style="background:#22c55e44;border-color:#22c55e"></div>Storage</div>
  <div class="legend-item"><div class="legend-dot" style="background:#8b5cf644;border-color:#8b5cf6"></div>Recovery</div>
</div>

<script>
(function () {
  'use strict';

  // ==============================================================
  //  CONSTANTS
  // ==============================================================
  const NW = 178, NH = 78, SVG_W = 1080, SVG_H = 580;

  // ==============================================================
  //  NODE DEFINITIONS
  // ==============================================================
  const NODES = {
    ws:     { id:'ws',     label:'WebSocket',      sub:'Receives audio_chunk', icon:'\u{1F50C}', color:'#a78bfa' },
    audio:  { id:'audio',  label:'audio_bytes',     sub:'In-memory local var',  icon:'\u{1F4E6}', color:'#6366f1' },
    groq:   { id:'groq',   label:'Groq Whisper',    sub:'Primary STT',          icon:'\u{1F5E3}\u{FE0F}', color:'#0ea5e9' },
    gemini: { id:'gemini', label:'Gemini STT',       sub:'Fallback #1',          icon:'\u{1F5E3}\u{FE0F}', color:'#14b8a6' },
    openai: { id:'openai', label:'OpenAI Whisper',   sub:'Fallback #2',          icon:'\u{1F5E3}\u{FE0F}', color:'#f59e0b' },
    dlq:    { id:'dlq',    label:'Redis DLQ',        sub:'Dead Letter Queue',    icon:'\u{1F504}', color:'#ef4444' },
    gcs:    { id:'gcs',    label:'GCS',              sub:'Audio persisted',       icon:'\u{2601}\u{FE0F}',  color:'#22c55e' },
    reproc: { id:'reproc', label:'Reprocessor',      sub:'Batch retry (later)',  icon:'\u{2699}\u{FE0F}',  color:'#8b5cf6' },
  };

  // Fixed positions (hand-tuned for clean layout)
  // Row 0: ws, audio  (centered pair)
  // Row 1: groq, gemini, openai  (evenly spaced)
  // Row 2: dlq, gcs, reproc  (evenly spaced)
  const ROW_Y = [40, 200, 390];
  const R1_X = (SVG_W - 3 * NW - 2 * 68) / 2;  // center 3 nodes with 68px gap
  const R0_X = R1_X + NW / 2 + 34;              // center 2 nodes relative to row 1

  const positions = {
    ws:     { x: R0_X,                    y: ROW_Y[0] },
    audio:  { x: R0_X + NW + 68,         y: ROW_Y[0] },
    groq:   { x: R1_X,                    y: ROW_Y[1] },
    gemini: { x: R1_X + NW + 68,         y: ROW_Y[1] },
    openai: { x: R1_X + 2 * (NW + 68),   y: ROW_Y[1] },
    dlq:    { x: R1_X,                    y: ROW_Y[2] },
    gcs:    { x: R1_X + NW + 68,         y: ROW_Y[2] },
    reproc: { x: R1_X + 2 * (NW + 68),   y: ROW_Y[2] },
  };

  Object.keys(NODES).forEach(k => {
    const n = NODES[k], p = positions[k];
    n.x = p.x; n.y = p.y;
    n.cx = p.x + NW / 2;
    n.cy = p.y + NH / 2;
    // port helpers
    n.top    = { x: n.cx, y: n.y };
    n.bottom = { x: n.cx, y: n.y + NH };
    n.left   = { x: n.x, y: n.cy };
    n.right  = { x: n.x + NW, y: n.cy };
  });

  // ==============================================================
  //  EDGE DEFINITIONS (with explicit paths for clean routing)
  // ==============================================================
  function makePath(pts) {
    if (pts.length === 2) {
      const [a, b] = pts;
      const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
      return `M${a.x},${a.y} Q${mx},${my} ${b.x},${b.y}`;
    }
    if (pts.length === 3) {
      return `M${pts[0].x},${pts[0].y} Q${pts[1].x},${pts[1].y} ${pts[2].x},${pts[2].y}`;
    }
    if (pts.length === 4) {
      return `M${pts[0].x},${pts[0].y} C${pts[1].x},${pts[1].y} ${pts[2].x},${pts[2].y} ${pts[3].x},${pts[3].y}`;
    }
    // fallback: polyline
    let d = `M${pts[0].x},${pts[0].y}`;
    for (let i = 1; i < pts.length; i++) d += ` L${pts[i].x},${pts[i].y}`;
    return d;
  }

  const N = NODES;
  const EDGES = [
    { id:'ws-audio',     d: makePath([N.ws.right, N.audio.left]) },
    { id:'audio-groq',   d: makePath([N.audio.bottom, {x:N.audio.cx,y:N.audio.cy+50}, N.groq.top]) },
    { id:'audio-gemini', d: makePath([N.audio.bottom, N.gemini.top]) },
    { id:'audio-openai', d: makePath([N.audio.bottom, {x:N.audio.cx,y:N.audio.cy+50}, N.openai.top]) },
    { id:'audio-dlq',    d: makePath([
      N.audio.bottom,
      {x: N.audio.cx - 40, y: N.audio.cy + 80},
      {x: N.dlq.cx, y: N.dlq.cy - 60},
      N.dlq.top
    ])},
    { id:'audio-gcs',    d: makePath([N.audio.bottom, {x:N.audio.cx,y:N.gcs.cy-50}, N.gcs.top]) },
    { id:'dlq-reproc',   d: makePath([N.dlq.right, N.reproc.left]) },
    { id:'reproc-gcs',   d: makePath([N.reproc.left, {x:(N.reproc.x+N.gcs.x+NW)/2, y:N.reproc.cy-10}, N.gcs.right]) },
    { id:'reproc-groq',  d: makePath([
      N.reproc.top,
      {x: N.reproc.cx + 50, y: N.reproc.cy - 80},
      {x: N.groq.cx + 60, y: N.groq.cy + 60},
      {x: N.groq.cx, y: N.groq.y + NH}
    ])},
  ];

  // Edge lookup
  const edgeMap = {};
  EDGES.forEach(e => { edgeMap[e.id] = e; });

  // ==============================================================
  //  STEP DEFINITIONS
  // ==============================================================
  const STEPS = [
    {
      title: 'Audio Chunk Arrives',
      desc: 'Client sends base64 WAV audio chunk over WebSocket. Decoded to <code>audio_bytes</code> -- held in local scope for the entire retry window.',
      active: ['ws','audio'],
      edges: ['ws-audio'],
      dotColor: '#a78bfa',
      failed: [], dimmed: [], circuitOpen: [], badges: {},
    },
    {
      title: 'Attempt 1: Groq Whisper',
      desc: '<code>tenacity</code> sends <code>audio_bytes</code> to primary provider (Groq). Same in-memory reference -- zero copy overhead.',
      active: ['audio','groq'],
      edges: ['audio-groq'],
      dotColor: '#0ea5e9',
      failed: [], dimmed: [], circuitOpen: [], badges: {},
    },
    {
      title: 'Groq Fails -- 429 Rate Limited',
      desc: 'Groq returns <code>429</code>. <code>tenacity</code> waits 0.5s (exponential backoff) before retry attempt 2.',
      active: [],
      edges: [],
      dotColor: '#0ea5e9',
      failed: ['groq'], dimmed: [], circuitOpen: [],
      badges: { groq: { text: '429', style: 'red' } },
    },
    {
      title: 'Attempt 2: Groq Retry',
      desc: '<code>tenacity</code> retry #2 with same <code>audio_bytes</code>. Still in local scope -- no disk read needed.',
      active: ['audio','groq'],
      edges: ['audio-groq'],
      dotColor: '#0ea5e9',
      failed: [], dimmed: [], circuitOpen: [],
      badges: { groq: { text: '2 / 3', style: 'amber' } },
    },
    {
      title: 'Groq Fails Again -- 503',
      desc: 'Groq returns <code>503</code>. <code>tenacity</code> waits 1s. One more attempt before giving up on this provider.',
      active: [],
      edges: [],
      dotColor: '#0ea5e9',
      failed: ['groq'], dimmed: [], circuitOpen: [],
      badges: { groq: { text: '2 / 3 failed', style: 'red' } },
    },
    {
      title: 'Attempt 3: Groq Final Try',
      desc: '<code>tenacity</code> retry #3 (final). If this fails, <code>pybreaker</code> opens the circuit.',
      active: ['audio','groq'],
      edges: ['audio-groq'],
      dotColor: '#0ea5e9',
      failed: [], dimmed: [], circuitOpen: [],
      badges: { groq: { text: '3 / 3', style: 'amber' } },
    },
    {
      title: 'Groq Down -- Circuit Breaker OPEN',
      desc: '3 consecutive failures. <code>pybreaker</code> opens circuit -- all future requests fail-fast (no wasted time). Cooldown: 30s.',
      active: [],
      edges: [],
      dotColor: '#ef4444',
      failed: ['groq'], dimmed: ['groq'], circuitOpen: ['groq'],
      badges: { groq: { text: 'CIRCUIT OPEN', style: 'circuit' } },
    },
    {
      title: 'Fallback: Gemini STT',
      desc: 'Provider chain advances. Same <code>audio_bytes</code> passed to Gemini STT. Still the same in-memory reference.',
      active: ['audio','gemini'],
      edges: ['audio-gemini'],
      dotColor: '#14b8a6',
      failed: [], dimmed: ['groq'], circuitOpen: ['groq'],
      badges: { groq: { text: 'CIRCUIT OPEN', style: 'circuit' } },
    },
    {
      title: 'Gemini Fails -- Timeout',
      desc: 'Gemini times out after 5s. <code>tenacity</code> retries once, then chain advances to OpenAI.',
      active: [],
      edges: [],
      dotColor: '#14b8a6',
      failed: ['gemini'], dimmed: ['groq'], circuitOpen: ['groq'],
      badges: {
        groq:   { text: 'CIRCUIT OPEN', style: 'circuit' },
        gemini: { text: 'TIMEOUT', style: 'red' },
      },
    },
    {
      title: 'Fallback: OpenAI Whisper',
      desc: 'Last provider in chain. If OpenAI succeeds, transcript flows normally. If not...',
      active: ['audio','openai'],
      edges: ['audio-openai'],
      dotColor: '#f59e0b',
      failed: [], dimmed: ['groq','gemini'], circuitOpen: ['groq'],
      badges: {
        groq:   { text: 'CIRCUIT OPEN', style: 'circuit' },
        gemini: { text: 'FAILED', style: 'red' },
      },
    },
    {
      title: 'ALL PROVIDERS FAILED',
      desc: 'All 3 providers exhausted. <code>audio_bytes</code> cannot be transcribed right now. But the audio is NOT lost.',
      active: [],
      edges: [],
      dotColor: '#ef4444',
      failed: ['groq','gemini','openai'], dimmed: ['groq','gemini','openai'], circuitOpen: ['groq'],
      badges: {
        groq:   { text: 'CIRCUIT OPEN', style: 'circuit' },
        gemini: { text: 'FAILED', style: 'red' },
        openai: { text: 'FAILED', style: 'red' },
      },
      showBanner: true,
    },
    {
      title: 'Push to DLQ + GCS',
      desc: 'Audio already uploaded to GCS (fire-and-forget on arrival). Chunk metadata pushed to Redis DLQ: <code>{session_id, chunk_index, gcs_path, error, timestamp}</code>.',
      active: ['audio','dlq','gcs'],
      edges: ['audio-gcs','audio-dlq'],
      dotColor: '#22c55e',
      dotColors: { 'audio-gcs':'#22c55e', 'audio-dlq':'#ef4444' },
      failed: [], dimmed: ['groq','gemini','openai'], circuitOpen: ['groq'],
      badges: {
        groq:   { text: 'CIRCUIT OPEN', style: 'circuit' },
        gemini: { text: 'FAILED', style: 'red' },
        openai: { text: 'FAILED', style: 'red' },
      },
    },
    {
      title: 'Deferred Recovery',
      desc: 'Batch reprocessor (runs periodically) reads DLQ, fetches audio from GCS, retries STT when providers recover. Transcript appended to Redis session.',
      active: ['dlq','reproc','gcs','groq'],
      edges: ['dlq-reproc','reproc-gcs','reproc-groq'],
      dotColor: '#8b5cf6',
      failed: [], dimmed: [], circuitOpen: [],
      badges: { groq: { text: 'RECOVERED', style: 'green' } },
    },
  ];

  // ==============================================================
  //  SVG RENDERING
  // ==============================================================
  const svg    = document.getElementById('mainSvg');
  const edgesG = document.getElementById('edgesGroup');
  const nodesG = document.getElementById('nodesGroup');
  const dotsG  = document.getElementById('dotsGroup');

  // ---- Render edges ----
  EDGES.forEach(e => {
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', e.d);
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke', '#1e293b');
    path.setAttribute('stroke-width', '2');
    path.setAttribute('stroke-dasharray', '6,5');
    path.setAttribute('marker-end', 'url(#arr)');
    path.setAttribute('id', 'edge-' + e.id);
    edgesG.appendChild(path);
    e.el = path;
    e.len = path.getTotalLength();
  });

  // ---- Render nodes ----
  Object.values(NODES).forEach(n => {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.setAttribute('id', 'node-' + n.id);

    // outer glow rect (for pulse)
    const glow = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    glow.setAttribute('x', n.x - 4);
    glow.setAttribute('y', n.y - 4);
    glow.setAttribute('width', NW + 8);
    glow.setAttribute('height', NH + 8);
    glow.setAttribute('rx', '16');
    glow.setAttribute('fill', 'none');
    glow.setAttribute('stroke', n.color);
    glow.setAttribute('stroke-width', '0');
    glow.setAttribute('opacity', '0');
    glow.setAttribute('id', 'glow-' + n.id);
    g.appendChild(glow);

    // main rect
    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rect.setAttribute('x', n.x);
    rect.setAttribute('y', n.y);
    rect.setAttribute('width', NW);
    rect.setAttribute('height', NH);
    rect.setAttribute('rx', '12');
    rect.setAttribute('fill', '#1e293b');
    rect.setAttribute('stroke', n.color + '66');
    rect.setAttribute('stroke-width', '1.5');
    rect.setAttribute('id', 'rect-' + n.id);
    g.appendChild(rect);

    // icon bg circle
    const iconBg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    iconBg.setAttribute('cx', n.x + 26);
    iconBg.setAttribute('cy', n.cy);
    iconBg.setAttribute('r', '18');
    iconBg.setAttribute('fill', n.color + '18');
    g.appendChild(iconBg);

    // icon
    const ico = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    ico.setAttribute('x', n.x + 26);
    ico.setAttribute('y', n.cy + 1);
    ico.setAttribute('font-size', '20');
    ico.setAttribute('text-anchor', 'middle');
    ico.setAttribute('dominant-baseline', 'central');
    ico.textContent = n.icon;
    g.appendChild(ico);

    // label
    const lbl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    lbl.setAttribute('x', n.x + 52);
    lbl.setAttribute('y', n.cy - 8);
    lbl.setAttribute('fill', '#f1f5f9');
    lbl.setAttribute('font-size', '12.5');
    lbl.setAttribute('font-weight', '700');
    lbl.setAttribute('dominant-baseline', 'middle');
    lbl.textContent = n.label;
    g.appendChild(lbl);

    // sub
    const sub = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    sub.setAttribute('x', n.x + 52);
    sub.setAttribute('y', n.cy + 12);
    sub.setAttribute('fill', '#64748b');
    sub.setAttribute('font-size', '10');
    sub.setAttribute('font-weight', '500');
    sub.setAttribute('dominant-baseline', 'middle');
    sub.textContent = n.sub;
    g.appendChild(sub);

    // badge group
    const bG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    bG.setAttribute('id', 'badge-' + n.id);
    bG.style.display = 'none';

    const bRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    bRect.setAttribute('rx', '5');
    bRect.setAttribute('height', '18');
    bRect.setAttribute('id', 'bRect-' + n.id);
    bG.appendChild(bRect);

    const bTxt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    bTxt.setAttribute('y', '13');
    bTxt.setAttribute('fill', '#fff');
    bTxt.setAttribute('font-size', '9.5');
    bTxt.setAttribute('font-weight', '800');
    bTxt.setAttribute('letter-spacing', '0.04em');
    bTxt.setAttribute('id', 'bTxt-' + n.id);
    bG.appendChild(bTxt);

    g.appendChild(bG);
    nodesG.appendChild(g);
  });

  // ---- Progress pips ----
  const progressWrap = document.getElementById('progressWrap');
  STEPS.forEach((_, i) => {
    const pip = document.createElement('div');
    pip.className = 'progress-pip';
    pip.addEventListener('click', () => goToStep(i));
    progressWrap.appendChild(pip);
  });
  const pips = progressWrap.children;

  // ==============================================================
  //  STATE MACHINE
  // ==============================================================
  let currentStep = -1;
  let playing = true;
  let timer = null;
  let dotAnims = [];  // { edgeId, t, speed, color, trail:[] }
  let rafId = null;

  function speed() { return parseInt(document.getElementById('speedSelect').value, 10); }

  // Badge style presets
  const BADGE_STYLES = {
    red:     { bg: '#dc2626', border: '#fca5a5' },
    amber:   { bg: '#d97706', border: '#fbbf24' },
    circuit: { bg: '#7f1d1d', border: '#ef4444' },
    green:   { bg: '#16a34a', border: '#4ade80' },
  };

  function applyStep(idx) {
    const s = STEPS[idx];

    // --- Reset nodes ---
    Object.values(NODES).forEach(n => {
      const rect = document.getElementById('rect-' + n.id);
      const glow = document.getElementById('glow-' + n.id);
      rect.setAttribute('fill', '#1e293b');
      rect.setAttribute('stroke', n.color + '66');
      rect.setAttribute('stroke-width', '1.5');
      glow.setAttribute('stroke-width', '0');
      glow.setAttribute('opacity', '0');
      document.getElementById('badge-' + n.id).style.display = 'none';
    });

    // --- Reset edges ---
    EDGES.forEach(e => {
      e.el.setAttribute('stroke', '#1e293b');
      e.el.setAttribute('stroke-width', '2');
      e.el.setAttribute('stroke-dasharray', '6,5');
      e.el.setAttribute('marker-end', 'url(#arr)');
    });

    // --- Banner ---
    const banner = document.getElementById('failBanner');
    if (s.showBanner) banner.classList.add('visible');
    else banner.classList.remove('visible');

    // --- Dimmed ---
    (s.dimmed || []).forEach(id => {
      const r = document.getElementById('rect-' + id);
      r.setAttribute('fill', '#111827');
      r.setAttribute('stroke', '#334155');
      r.style.opacity = '0.45';
    });

    // --- Failed (red glow) ---
    (s.failed || []).forEach(id => {
      const r = document.getElementById('rect-' + id);
      r.setAttribute('stroke', '#ef4444');
      r.setAttribute('stroke-width', '2.5');
      if (!(s.dimmed || []).includes(id)) {
        r.setAttribute('fill', '#1a0a0a');
      }
    });

    // --- Circuit open ---
    (s.circuitOpen || []).forEach(id => {
      const r = document.getElementById('rect-' + id);
      r.setAttribute('fill', '#0f0f0f');
      r.setAttribute('stroke', '#475569');
      r.style.opacity = '0.4';
    });

    // --- Active nodes (pulse glow) ---
    (s.active || []).forEach(id => {
      const n = NODES[id];
      const r = document.getElementById('rect-' + id);
      const g = document.getElementById('glow-' + id);
      r.setAttribute('fill', '#1e293b');
      r.setAttribute('stroke', n.color);
      r.setAttribute('stroke-width', '2');
      r.style.opacity = '1';
      g.setAttribute('stroke', n.color);
      g.setAttribute('stroke-width', '2');
      g.setAttribute('opacity', '0.5');
      // CSS animation pulse
      g.style.animation = 'nodePulse 1.8s ease-in-out infinite';
    });

    // --- Reset opacity for non-dimmed non-circuit ---
    Object.values(NODES).forEach(n => {
      if (!(s.dimmed || []).includes(n.id) && !(s.circuitOpen || []).includes(n.id)) {
        document.getElementById('rect-' + n.id).style.opacity = '1';
      }
    });

    // --- Badges ---
    Object.entries(s.badges || {}).forEach(([nid, cfg]) => {
      const bG   = document.getElementById('badge-' + nid);
      const bR   = document.getElementById('bRect-' + nid);
      const bT   = document.getElementById('bTxt-' + nid);
      const node = NODES[nid];
      const st   = BADGE_STYLES[cfg.style] || BADGE_STYLES.red;

      bG.style.display = '';
      bT.textContent = cfg.text;

      const w = cfg.text.length * 7.2 + 18;
      bR.setAttribute('width', w);
      bR.setAttribute('fill', st.bg);
      bR.setAttribute('stroke', st.border);
      bR.setAttribute('stroke-width', '1');
      bT.setAttribute('x', '9');

      const bx = node.x + NW - w + 12;
      const by = node.y - 12;
      bG.setAttribute('transform', `translate(${bx},${by})`);
    });

    // --- Highlight active edges ---
    (s.edges || []).forEach(eid => {
      const e = edgeMap[eid];
      if (!e) return;
      e.el.setAttribute('stroke', '#475569');
      e.el.setAttribute('stroke-width', '2.5');
      e.el.setAttribute('stroke-dasharray', '8,4');
      e.el.setAttribute('marker-end', 'url(#arr-hi)');
    });

    // --- Animated dots ---
    clearDots();
    (s.edges || []).forEach(eid => {
      const colors = s.dotColors || {};
      const color  = colors[eid] || s.dotColor || '#a78bfa';
      const spd    = 0.9 / (speed() / 1000);
      dotAnims.push({ edgeId: eid, t: 0, speed: spd, color, trail: [] });

      // main dot
      const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      c.setAttribute('r', '5');
      c.setAttribute('fill', color);
      c.setAttribute('filter', 'url(#dotGlow)');
      c.setAttribute('id', 'dot-' + eid);
      dotsG.appendChild(c);

      // trail dots (3 smaller trailing)
      for (let ti = 0; ti < 3; ti++) {
        const tc = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        tc.setAttribute('r', String(3.5 - ti * 0.8));
        tc.setAttribute('fill', color);
        tc.setAttribute('opacity', String(0.5 - ti * 0.15));
        tc.setAttribute('id', `trail-${eid}-${ti}`);
        dotsG.appendChild(tc);
      }
    });

    // --- Info panel ---
    document.getElementById('stepLabel').textContent = `Step ${idx + 1} of ${STEPS.length}`;
    document.getElementById('stepTitle').textContent = s.title;
    document.getElementById('stepDesc').innerHTML = s.desc;
    document.getElementById('stepCounter').textContent = `${idx + 1} / ${STEPS.length}`;

    // --- Info panel border tint ---
    const panel = document.getElementById('infoPanel');
    if (s.showBanner) panel.style.borderColor = '#ef444488';
    else if (s.failed && s.failed.length) panel.style.borderColor = '#ef444444';
    else panel.style.borderColor = '#334155';

    // --- Progress pips ---
    for (let i = 0; i < pips.length; i++) {
      pips[i].className = 'progress-pip' +
        (i < idx ? ' done' : '') +
        (i === idx ? ' active done' : '');
    }

    // --- Button state ---
    document.getElementById('btnPrev').disabled = idx === 0;
    document.getElementById('btnNext').disabled = idx === STEPS.length - 1;
  }

  function clearDots() {
    while (dotsG.firstChild) dotsG.removeChild(dotsG.firstChild);
    dotAnims = [];
  }

  // ==============================================================
  //  ANIMATION LOOP (requestAnimationFrame)
  // ==============================================================
  let lastT = 0;

  function tick(ts) {
    const dt = Math.min((ts - lastT) / 1000, 0.1);
    lastT = ts;

    dotAnims.forEach(da => {
      const edge = edgeMap[da.edgeId];
      if (!edge) return;

      da.t += dt * da.speed;
      if (da.t > 1) da.t -= 1;

      const pt = edge.el.getPointAtLength(da.t * edge.len);
      const dot = document.getElementById('dot-' + da.edgeId);
      if (dot) {
        dot.setAttribute('cx', pt.x);
        dot.setAttribute('cy', pt.y);
      }

      // trailing dots at earlier t values
      for (let ti = 0; ti < 3; ti++) {
        const trailT = da.t - (ti + 1) * 0.06;
        const tt = trailT < 0 ? trailT + 1 : trailT;
        const tp = edge.el.getPointAtLength(tt * edge.len);
        const te = document.getElementById(`trail-${da.edgeId}-${ti}`);
        if (te) {
          te.setAttribute('cx', tp.x);
          te.setAttribute('cy', tp.y);
        }
      }
    });

    // Pulse glow rects (use sine wave)
    const pulse = 0.3 + 0.7 * Math.abs(Math.sin(ts / 600));
    const step = STEPS[currentStep];
    if (step) {
      (step.active || []).forEach(nid => {
        const g = document.getElementById('glow-' + nid);
        if (g) g.setAttribute('opacity', String(pulse * 0.5));
      });
    }

    rafId = requestAnimationFrame(tick);
  }

  // ==============================================================
  //  PLAYBACK CONTROLS
  // ==============================================================
  function scheduleNext() {
    clearTimeout(timer);
    if (!playing) return;
    timer = setTimeout(() => {
      if (currentStep < STEPS.length - 1) {
        currentStep++;
      } else {
        currentStep = 0;
      }
      applyStep(currentStep);
      scheduleNext();
    }, speed());
  }

  function goToStep(idx) {
    clearTimeout(timer);
    currentStep = Math.max(0, Math.min(STEPS.length - 1, idx));
    applyStep(currentStep);
    if (playing) scheduleNext();
  }

  document.getElementById('btnPrev').addEventListener('click', () => goToStep(currentStep - 1));
  document.getElementById('btnNext').addEventListener('click', () => goToStep(currentStep + 1));

  document.getElementById('btnPlay').addEventListener('click', () => {
    playing = !playing;
    const btn = document.getElementById('btnPlay');
    btn.textContent = playing ? 'Pause' : 'Play';
    btn.classList.toggle('primary', playing);
    if (playing) scheduleNext();
    else clearTimeout(timer);
  });

  document.getElementById('speedSelect').addEventListener('change', () => {
    if (playing) {
      clearTimeout(timer);
      scheduleNext();
    }
  });

  // Keyboard controls
  document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') { e.preventDefault(); goToStep(currentStep - 1); }
    if (e.key === 'ArrowRight' || e.key === 'ArrowDown') { e.preventDefault(); goToStep(currentStep + 1); }
    if (e.key === ' ') {
      e.preventDefault();
      document.getElementById('btnPlay').click();
    }
  });

  // ==============================================================
  //  INIT
  // ==============================================================
  currentStep = 0;
  applyStep(0);
  lastT = performance.now();
  rafId = requestAnimationFrame(tick);
  scheduleNext();

})();
</script>
</body>
</html>
