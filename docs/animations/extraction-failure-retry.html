<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Extraction Failure &amp; Retry Flow -- Animated Dataflow</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: #0f172a;
    color: #e2e8f0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 28px 16px 56px;
    overflow-x: hidden;
  }

  h1 {
    font-size: 1.6rem;
    font-weight: 800;
    letter-spacing: -0.03em;
    margin-bottom: 2px;
    color: #f8fafc;
  }

  .subtitle {
    font-size: 0.85rem;
    color: #64748b;
    margin-bottom: 24px;
    letter-spacing: 0.01em;
  }

  /* ---- SVG canvas ---- */
  .svg-wrap {
    width: 100%;
    max-width: 1120px;
    border: 1px solid #1e293b;
    border-radius: 16px;
    background: linear-gradient(180deg, #0f172a 0%, #0c1322 100%);
    position: relative;
    overflow: visible;
    box-shadow: 0 4px 32px #0008;
  }

  svg { display: block; width: 100%; height: auto; }

  /* ---- Info panel ---- */
  .info-panel {
    width: 100%;
    max-width: 1120px;
    margin-top: 16px;
    padding: 22px 28px;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 12px;
    min-height: 92px;
    transition: border-color 0.4s;
  }

  .info-panel .step-label {
    font-size: 0.7rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #475569;
    margin-bottom: 4px;
  }

  .info-panel .step-title {
    font-size: 1.2rem;
    font-weight: 800;
    color: #f1f5f9;
    margin-bottom: 8px;
  }

  .info-panel .step-desc {
    font-size: 0.88rem;
    line-height: 1.6;
    color: #94a3b8;
  }

  .info-panel .step-desc code {
    background: #334155;
    padding: 1px 6px;
    border-radius: 4px;
    font-size: 0.82rem;
    color: #e2e8f0;
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  }

  /* ---- Controls ---- */
  .controls {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 16px;
    width: 100%;
    max-width: 1120px;
    justify-content: center;
    flex-wrap: wrap;
  }

  .ctrl-btn {
    background: #1e293b;
    border: 1px solid #334155;
    color: #e2e8f0;
    border-radius: 8px;
    padding: 9px 20px;
    font-size: 0.82rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
    letter-spacing: 0.02em;
  }

  .ctrl-btn:hover { background: #334155; border-color: #475569; }
  .ctrl-btn:active { background: #475569; transform: scale(0.97); }
  .ctrl-btn.primary { background: #6366f1; border-color: #6366f1; color: #fff; }
  .ctrl-btn.primary:hover { background: #818cf8; border-color: #818cf8; }
  .ctrl-btn:disabled { opacity: 0.3; cursor: default; pointer-events: none; }

  .speed-select {
    background: #1e293b;
    border: 1px solid #334155;
    color: #e2e8f0;
    border-radius: 8px;
    padding: 9px 14px;
    font-size: 0.8rem;
    cursor: pointer;
    outline: none;
    font-weight: 600;
  }

  .speed-select:focus { border-color: #6366f1; }

  .step-counter {
    color: #64748b;
    font-size: 0.8rem;
    font-weight: 600;
    min-width: 70px;
    text-align: center;
    letter-spacing: 0.02em;
  }

  /* ---- Progress bar ---- */
  .progress-wrap {
    width: 100%;
    max-width: 1120px;
    margin-top: 14px;
    display: flex;
    gap: 3px;
  }

  .progress-pip {
    flex: 1;
    height: 4px;
    border-radius: 2px;
    background: #1e293b;
    transition: background 0.35s, box-shadow 0.35s;
    cursor: pointer;
  }

  .progress-pip:hover { background: #334155; }
  .progress-pip.done { background: #4f46e5; }
  .progress-pip.active { background: #a78bfa; box-shadow: 0 0 8px #a78bfa66; }

  /* ---- Failure banner ---- */
  .failure-banner {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: linear-gradient(135deg, #dc2626ee, #991b1bee);
    color: #fff;
    font-weight: 900;
    font-size: 1.15rem;
    padding: 12px 32px;
    border-radius: 12px;
    letter-spacing: 0.06em;
    pointer-events: none;
    transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.4s;
    opacity: 0;
    z-index: 10;
    white-space: nowrap;
    border: 2px solid #fca5a5;
    box-shadow: 0 0 40px #dc262666;
  }

  .failure-banner.visible {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }

  /* ---- Pulse keyframes for node glow ---- */
  @keyframes nodePulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
  }

  /* ---- Legend ---- */
  .legend {
    display: flex;
    gap: 20px;
    margin-top: 18px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.75rem;
    color: #64748b;
    font-weight: 600;
  }

  .legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    border: 2px solid;
  }
</style>
</head>
<body>

<h1>Extraction Failure &amp; Retry Flow</h1>
<p class="subtitle">How LLM extraction recovers from failures</p>

<div class="svg-wrap" id="svgWrap">
  <div class="failure-banner" id="failBanner">GEMINI DOWN -- 503</div>
  <svg id="mainSvg" viewBox="0 0 1080 580" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <marker id="arr" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto" markerUnits="strokeWidth">
        <path d="M0,0 L10,3.5 L0,7" fill="#334155" />
      </marker>
      <marker id="arr-hi" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto" markerUnits="strokeWidth">
        <path d="M0,0 L10,3.5 L0,7" fill="#818cf8" />
      </marker>
      <!-- glow for dots -->
      <filter id="dotGlow" x="-100%" y="-100%" width="300%" height="300%">
        <feGaussianBlur stdDeviation="4" result="g" />
        <feMerge><feMergeNode in="g" /><feMergeNode in="SourceGraphic" /></feMerge>
      </filter>
      <!-- subtle grid pattern -->
      <pattern id="grid" width="30" height="30" patternUnits="userSpaceOnUse">
        <path d="M30,0 L0,0 0,30" fill="none" stroke="#1e293b" stroke-width="0.5" opacity="0.5" />
      </pattern>
    </defs>

    <!-- background grid -->
    <rect width="1080" height="580" fill="url(#grid)" />

    <g id="edgesGroup"></g>
    <g id="nodesGroup"></g>
    <g id="dotsGroup"></g>
  </svg>
</div>

<div class="info-panel" id="infoPanel">
  <div class="step-label" id="stepLabel">Step 1 / 10</div>
  <div class="step-title" id="stepTitle">--</div>
  <div class="step-desc" id="stepDesc">--</div>
</div>

<div class="progress-wrap" id="progressWrap"></div>

<div class="controls">
  <button class="ctrl-btn" id="btnPrev" title="Previous step">Prev</button>
  <button class="ctrl-btn primary" id="btnPlay" title="Play / Pause">Pause</button>
  <button class="ctrl-btn" id="btnNext" title="Next step">Next</button>
  <span class="step-counter" id="stepCounter">1 / 10</span>
  <select class="speed-select" id="speedSelect" title="Animation speed">
    <option value="5000">Slow (5s)</option>
    <option value="3200" selected>Normal (3.2s)</option>
    <option value="1800">Fast (1.8s)</option>
    <option value="900">Turbo (0.9s)</option>
  </select>
</div>

<div class="legend">
  <div class="legend-item"><div class="legend-dot" style="background:#22c55e44;border-color:#22c55e"></div>Extraction</div>
  <div class="legend-item"><div class="legend-dot" style="background:#0ea5e944;border-color:#0ea5e9"></div>Transcript</div>
  <div class="legend-item"><div class="legend-dot" style="background:#14b8a644;border-color:#14b8a6"></div>Primary LLM</div>
  <div class="legend-item"><div class="legend-dot" style="background:#f59e0b44;border-color:#f59e0b"></div>Fallback #1</div>
  <div class="legend-item"><div class="legend-dot" style="background:#ef444444;border-color:#ef4444"></div>Failure / Error</div>
  <div class="legend-item"><div class="legend-dot" style="background:#a78bfa44;border-color:#a78bfa"></div>WebSocket</div>
  <div class="legend-item"><div class="legend-dot" style="background:#6366f144;border-color:#6366f1"></div>Validation</div>
</div>

<script>
(function () {
  'use strict';

  // ==============================================================
  //  CONSTANTS
  // ==============================================================
  const NW = 140, NH = 52, NR = 12, SVG_W = 1080, SVG_H = 580;

  // ==============================================================
  //  TYPE COLORS
  // ==============================================================
  const TYPE_COLORS = {
    extraction: '#22c55e',
    transcript: '#0ea5e9',
    error:      '#ef4444',
  };

  // ==============================================================
  //  STAGE (NODE) DEFINITIONS
  // ==============================================================
  const STAGES = [
    { id: 'transcript',   label: 'Full Transcript',       sublabel: 'From Redis session',    x: 80,  y: 70,  color: '#0ea5e9', icon: '\uD83D\uDCDD' },
    { id: 'patient',      label: 'Patient Context',       sublabel: 'Name, age, gender',     x: 280, y: 70,  color: '#a78bfa', icon: '\uD83D\uDC64' },
    { id: 'prev_extract', label: 'Previous Extraction',   sublabel: 'Cumulative state',      x: 500, y: 70,  color: '#8b5cf6', icon: '\uD83D\uDCE6' },

    { id: 'gemini',       label: 'Gemini 2.5 Flash',      sublabel: 'Primary LLM',           x: 120, y: 210, color: '#14b8a6', icon: '\uD83E\uDDE0' },
    { id: 'openai',       label: 'OpenAI GPT',            sublabel: 'Fallback #1',           x: 350, y: 210, color: '#f59e0b', icon: '\uD83E\uDDE0' },
    { id: 'groq',         label: 'Groq LLaMA',            sublabel: 'Fallback #2',           x: 570, y: 210, color: '#ef4444', icon: '\uD83E\uDDE0' },

    { id: 'json_parse',   label: 'JSON Validate',         sublabel: 'ExtractionResult schema', x: 120, y: 350, color: '#6366f1', icon: '\uD83D\uDCCB' },
    { id: 'merge',        label: 'Merge State',           sublabel: 'Cumulative merge',      x: 350, y: 350, color: '#22c55e', icon: '\uD83D\uDD00' },

    { id: 'redis',        label: 'Redis',                 sublabel: 'Save extraction',       x: 120, y: 490, color: '#ef4444', icon: '\uD83D\uDD34' },
    { id: 'websocket',    label: 'WebSocket',             sublabel: 'Send update',           x: 350, y: 490, color: '#a78bfa', icon: '\uD83D\uDD0C' },
    { id: 'ui',           label: 'Overlay Panel',         sublabel: '5 extraction cards',    x: 570, y: 490, color: '#f59e0b', icon: '\uD83D\uDDA5\uFE0F' },
  ];

  // Build node lookup and compute center / port helpers
  const nodeMap = {};
  STAGES.forEach(n => {
    n.cx = n.x + NW / 2;
    n.cy = n.y + NH / 2;
    n.top    = { x: n.cx, y: n.y };
    n.bottom = { x: n.cx, y: n.y + NH };
    n.left   = { x: n.x,  y: n.cy };
    n.right  = { x: n.x + NW, y: n.cy };
    nodeMap[n.id] = n;
  });

  function getStage(id) { return nodeMap[id]; }

  // ==============================================================
  //  EDGE DEFINITIONS (with explicit bezier paths)
  // ==============================================================
  function makePath(pts) {
    if (pts.length === 2) {
      const [a, b] = pts;
      const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
      return 'M' + a.x + ',' + a.y + ' Q' + mx + ',' + my + ' ' + b.x + ',' + b.y;
    }
    if (pts.length === 3) {
      return 'M' + pts[0].x + ',' + pts[0].y + ' Q' + pts[1].x + ',' + pts[1].y + ' ' + pts[2].x + ',' + pts[2].y;
    }
    if (pts.length === 4) {
      return 'M' + pts[0].x + ',' + pts[0].y + ' C' + pts[1].x + ',' + pts[1].y + ' ' + pts[2].x + ',' + pts[2].y + ' ' + pts[3].x + ',' + pts[3].y;
    }
    let d = 'M' + pts[0].x + ',' + pts[0].y;
    for (let i = 1; i < pts.length; i++) d += ' L' + pts[i].x + ',' + pts[i].y;
    return d;
  }

  const N = nodeMap;

  // primary: transcript -> LLMs, LLMs -> json_parse
  // merge_flow: json_parse -> merge, prev_extract -> merge
  // output: merge -> redis -> websocket -> ui
  const EDGES = [
    // transcript -> gemini
    { id: 'transcript-gemini',   d: makePath([ N.transcript.bottom, { x: N.transcript.cx, y: N.transcript.cy + 50 }, N.gemini.top ]),   type: 'extraction' },
    // transcript -> openai
    { id: 'transcript-openai',   d: makePath([ N.transcript.bottom, { x: (N.transcript.cx + N.openai.cx) / 2, y: N.transcript.cy + 60 }, N.openai.top ]),   type: 'extraction' },
    // transcript -> groq
    { id: 'transcript-groq',     d: makePath([ N.transcript.bottom, { x: (N.transcript.cx + N.groq.cx) / 2, y: N.transcript.cy + 55 }, N.groq.top ]),       type: 'extraction' },
    // gemini -> json_parse
    { id: 'gemini-json_parse',   d: makePath([ N.gemini.bottom, N.json_parse.top ]),     type: 'extraction' },
    // openai -> json_parse
    { id: 'openai-json_parse',   d: makePath([ N.openai.bottom, { x: (N.openai.cx + N.json_parse.cx) / 2, y: N.openai.cy + 55 }, N.json_parse.top ]),   type: 'extraction' },
    // groq -> json_parse
    { id: 'groq-json_parse',     d: makePath([ N.groq.bottom, { x: (N.groq.cx + N.json_parse.cx) / 2, y: N.groq.cy + 55 }, N.json_parse.top ]),         type: 'extraction' },

    // json_parse -> merge
    { id: 'json_parse-merge',    d: makePath([ N.json_parse.right, N.merge.left ]),   type: 'transcript' },
    // prev_extract -> merge
    { id: 'prev_extract-merge',  d: makePath([ N.prev_extract.bottom, { x: N.prev_extract.cx, y: N.prev_extract.cy + 80 }, { x: N.merge.cx + 30, y: N.merge.cy - 40 }, N.merge.top ]),   type: 'transcript' },

    // merge -> redis
    { id: 'merge-redis',         d: makePath([ N.merge.bottom, { x: (N.merge.cx + N.redis.cx) / 2, y: N.merge.cy + 55 }, N.redis.top ]),   type: 'extraction' },
    // redis -> websocket
    { id: 'redis-websocket',     d: makePath([ N.redis.right, N.websocket.left ]),   type: 'extraction' },
    // websocket -> ui
    { id: 'websocket-ui',        d: makePath([ N.websocket.right, N.ui.left ]),   type: 'extraction' },
  ];

  // Edge lookup
  const edgeMap = {};
  EDGES.forEach(e => { edgeMap[e.id] = e; });

  // Helper to build an edge id from two node ids
  function getEdge(from, to) { return from + '-' + to; }

  // ==============================================================
  //  STEP DEFINITIONS
  // ==============================================================
  const STEPS = [
    {
      name: 'Extraction Triggered',
      desc: 'Extraction throttled to max 1 per 5s. Full transcript (all chunks so far) + patient context assembled for LLM.',
      activeNodes: ['transcript', 'patient'],
      activeEdges: [],
      duration: 2000,
      dotColor: TYPE_COLORS.transcript,
      failed: [], dimmed: [], badges: {},
    },
    {
      name: 'Attempt 1: Gemini',
      desc: '<code>tenacity</code> sends full transcript to primary provider (Gemini 2.5 Flash) with <code>response_schema=ExtractionResult</code> for structured JSON.',
      activeNodes: ['transcript', 'gemini'],
      activeEdges: [['transcript', 'gemini']],
      duration: 2000,
      dotColor: TYPE_COLORS.extraction,
      failed: [], dimmed: [], badges: {},
    },
    {
      name: 'Gemini: Malformed JSON',
      desc: 'Gemini returned text that doesn\'t match ExtractionResult schema. <code>json.JSONDecodeError</code> caught. <code>tenacity</code> retries (backoff: 1s).',
      activeNodes: ['gemini', 'json_parse'],
      activeEdges: [['gemini', 'json_parse']],
      duration: 2200,
      isError: true,
      dotColor: TYPE_COLORS.error,
      failed: ['json_parse'], dimmed: [], badges: { json_parse: { text: 'MALFORMED', style: 'red' } },
    },
    {
      name: 'Retry: Gemini Attempt 2',
      desc: '<code>tenacity</code> retry #2. Same transcript -- rebuilt from <code>session.get_full_transcript()</code>. If it fails again, provider is exhausted.',
      activeNodes: ['transcript', 'gemini'],
      activeEdges: [['transcript', 'gemini']],
      duration: 2000,
      dotColor: TYPE_COLORS.extraction,
      failed: [], dimmed: [], badges: { gemini: { text: '2 / 2', style: 'amber' } },
    },
    {
      name: 'Gemini Down -- 503',
      desc: 'Gemini returns <code>503</code>. <code>tenacity</code> exhausted (2 attempts). <code>pybreaker</code> increments failure count (1/3). Chain advances to next provider.',
      activeNodes: ['gemini'],
      activeEdges: [],
      duration: 2200,
      isError: true,
      dotColor: TYPE_COLORS.error,
      failed: ['gemini'], dimmed: ['gemini'], badges: { gemini: { text: '503 FAILED', style: 'circuit' } },
      showBanner: true,
    },
    {
      name: 'Fallback: OpenAI GPT',
      desc: 'Provider chain advances. Same transcript passed to OpenAI GPT with <code>function_call</code> for structured output.',
      activeNodes: ['transcript', 'openai'],
      activeEdges: [['transcript', 'openai']],
      duration: 2000,
      dotColor: '#f59e0b',
      failed: [], dimmed: ['gemini'], badges: { gemini: { text: 'FAILED', style: 'red' } },
    },
    {
      name: 'OpenAI: Valid JSON',
      desc: 'OpenAI returns valid <code>ExtractionResult</code> JSON. Parsed and validated by Pydantic. 5 fields: chief_complaint, diagnosis, medicine, advice, next_steps.',
      activeNodes: ['openai', 'json_parse'],
      activeEdges: [['openai', 'json_parse']],
      duration: 2000,
      dotColor: '#f59e0b',
      failed: [], dimmed: ['gemini'], badges: { gemini: { text: 'FAILED', style: 'red' }, json_parse: { text: 'VALID', style: 'green' } },
    },
    {
      name: 'Merge with Previous',
      desc: 'New extraction merged with cumulative state from Redis. Fields are additive -- new findings appended (semicolon-separated), not replaced.',
      activeNodes: ['json_parse', 'merge', 'prev_extract'],
      activeEdges: [['json_parse', 'merge'], ['prev_extract', 'merge']],
      duration: 2000,
      dotColor: TYPE_COLORS.transcript,
      failed: [], dimmed: ['gemini'], badges: { gemini: { text: 'FAILED', style: 'red' } },
    },
    {
      name: 'Push to Client',
      desc: 'Merged extraction saved to Redis, then <code>extraction_update</code> sent over WebSocket to Chrome Extension overlay panel.',
      activeNodes: ['merge', 'redis', 'websocket', 'ui'],
      activeEdges: [['merge', 'redis'], ['redis', 'websocket'], ['websocket', 'ui']],
      duration: 2500,
      dotColor: TYPE_COLORS.extraction,
      failed: [], dimmed: ['gemini'], badges: { gemini: { text: 'FAILED', style: 'red' } },
    },
    {
      name: 'Self-Healing Insight',
      desc: 'Unlike STT, extraction is <strong>self-healing</strong>. Each attempt uses the FULL transcript -- including chunks from failed rounds. Data is never lost, only delayed.',
      activeNodes: ['transcript', 'redis', 'ui'],
      activeEdges: [],
      duration: 3000,
      isEnd: true,
      dotColor: TYPE_COLORS.extraction,
      failed: [], dimmed: [], badges: { transcript: { text: 'SELF-HEALING', style: 'green' } },
    },
  ];

  // ==============================================================
  //  SVG RENDERING
  // ==============================================================
  const svg    = document.getElementById('mainSvg');
  const edgesG = document.getElementById('edgesGroup');
  const nodesG = document.getElementById('nodesGroup');
  const dotsG  = document.getElementById('dotsGroup');

  // ---- Render edges ----
  EDGES.forEach(e => {
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', e.d);
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke', '#1e293b');
    path.setAttribute('stroke-width', '2');
    path.setAttribute('stroke-dasharray', '6,5');
    path.setAttribute('marker-end', 'url(#arr)');
    path.setAttribute('id', 'edge-' + e.id);
    edgesG.appendChild(path);
    e.el = path;
    e.len = path.getTotalLength();
  });

  // ---- Render nodes ----
  STAGES.forEach(n => {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.setAttribute('id', 'node-' + n.id);

    // outer glow rect (for pulse)
    const glow = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    glow.setAttribute('x', n.x - 4);
    glow.setAttribute('y', n.y - 4);
    glow.setAttribute('width', NW + 8);
    glow.setAttribute('height', NH + 8);
    glow.setAttribute('rx', NR + 4);
    glow.setAttribute('fill', 'none');
    glow.setAttribute('stroke', n.color);
    glow.setAttribute('stroke-width', '0');
    glow.setAttribute('opacity', '0');
    glow.setAttribute('id', 'glow-' + n.id);
    g.appendChild(glow);

    // main rect
    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rect.setAttribute('x', n.x);
    rect.setAttribute('y', n.y);
    rect.setAttribute('width', NW);
    rect.setAttribute('height', NH);
    rect.setAttribute('rx', NR);
    rect.setAttribute('fill', '#1e293b');
    rect.setAttribute('stroke', n.color + '66');
    rect.setAttribute('stroke-width', '1.5');
    rect.setAttribute('id', 'rect-' + n.id);
    g.appendChild(rect);

    // icon bg circle
    const iconBg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    iconBg.setAttribute('cx', n.x + 22);
    iconBg.setAttribute('cy', n.cy);
    iconBg.setAttribute('r', '14');
    iconBg.setAttribute('fill', n.color + '18');
    g.appendChild(iconBg);

    // icon
    const ico = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    ico.setAttribute('x', n.x + 22);
    ico.setAttribute('y', n.cy + 1);
    ico.setAttribute('font-size', '16');
    ico.setAttribute('text-anchor', 'middle');
    ico.setAttribute('dominant-baseline', 'central');
    ico.textContent = n.icon;
    g.appendChild(ico);

    // label
    const lbl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    lbl.setAttribute('x', n.x + 42);
    lbl.setAttribute('y', n.cy - 6);
    lbl.setAttribute('fill', '#f1f5f9');
    lbl.setAttribute('font-size', '11');
    lbl.setAttribute('font-weight', '700');
    lbl.setAttribute('dominant-baseline', 'middle');
    lbl.textContent = n.label;
    g.appendChild(lbl);

    // sub
    const sub = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    sub.setAttribute('x', n.x + 42);
    sub.setAttribute('y', n.cy + 10);
    sub.setAttribute('fill', '#64748b');
    sub.setAttribute('font-size', '9');
    sub.setAttribute('font-weight', '500');
    sub.setAttribute('dominant-baseline', 'middle');
    sub.textContent = n.sublabel;
    g.appendChild(sub);

    // badge group
    const bG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    bG.setAttribute('id', 'badge-' + n.id);
    bG.style.display = 'none';

    const bRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    bRect.setAttribute('rx', '5');
    bRect.setAttribute('height', '16');
    bRect.setAttribute('id', 'bRect-' + n.id);
    bG.appendChild(bRect);

    const bTxt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    bTxt.setAttribute('y', '12');
    bTxt.setAttribute('fill', '#fff');
    bTxt.setAttribute('font-size', '8.5');
    bTxt.setAttribute('font-weight', '800');
    bTxt.setAttribute('letter-spacing', '0.04em');
    bTxt.setAttribute('id', 'bTxt-' + n.id);
    bG.appendChild(bTxt);

    g.appendChild(bG);
    nodesG.appendChild(g);
  });

  // ---- Progress pips ----
  const progressWrap = document.getElementById('progressWrap');
  STEPS.forEach(function(_, i) {
    const pip = document.createElement('div');
    pip.className = 'progress-pip';
    pip.addEventListener('click', function() { goToStep(i); });
    progressWrap.appendChild(pip);
  });
  const pips = progressWrap.children;

  // ==============================================================
  //  STATE MACHINE
  // ==============================================================
  let currentStep = -1;
  let playing = true;
  let timer = null;
  let dotAnims = [];
  let rafId = null;

  function speed() { return parseInt(document.getElementById('speedSelect').value, 10); }

  // Badge style presets
  const BADGE_STYLES = {
    red:     { bg: '#dc2626', border: '#fca5a5' },
    amber:   { bg: '#d97706', border: '#fbbf24' },
    circuit: { bg: '#7f1d1d', border: '#ef4444' },
    green:   { bg: '#16a34a', border: '#4ade80' },
  };

  function applyStep(idx) {
    const s = STEPS[idx];

    // --- Reset nodes ---
    STAGES.forEach(n => {
      const rect = document.getElementById('rect-' + n.id);
      const glow = document.getElementById('glow-' + n.id);
      rect.setAttribute('fill', '#1e293b');
      rect.setAttribute('stroke', n.color + '66');
      rect.setAttribute('stroke-width', '1.5');
      rect.style.opacity = '1';
      glow.setAttribute('stroke-width', '0');
      glow.setAttribute('opacity', '0');
      glow.style.animation = '';
      document.getElementById('badge-' + n.id).style.display = 'none';
    });

    // --- Reset edges ---
    EDGES.forEach(e => {
      e.el.setAttribute('stroke', '#1e293b');
      e.el.setAttribute('stroke-width', '2');
      e.el.setAttribute('stroke-dasharray', '6,5');
      e.el.setAttribute('marker-end', 'url(#arr)');
    });

    // --- Banner ---
    var banner = document.getElementById('failBanner');
    if (s.showBanner) banner.classList.add('visible');
    else banner.classList.remove('visible');

    // --- Dimmed ---
    (s.dimmed || []).forEach(function(id) {
      var r = document.getElementById('rect-' + id);
      r.setAttribute('fill', '#111827');
      r.setAttribute('stroke', '#334155');
      r.style.opacity = '0.45';
    });

    // --- Failed (red glow) ---
    (s.failed || []).forEach(function(id) {
      var r = document.getElementById('rect-' + id);
      r.setAttribute('stroke', '#ef4444');
      r.setAttribute('stroke-width', '2.5');
      if (!(s.dimmed || []).includes(id)) {
        r.setAttribute('fill', '#1a0a0a');
      }
    });

    // --- Active nodes (pulse glow) ---
    (s.activeNodes || []).forEach(function(id) {
      var n = nodeMap[id];
      var r = document.getElementById('rect-' + id);
      var g = document.getElementById('glow-' + id);
      r.setAttribute('fill', '#1e293b');
      r.setAttribute('stroke', n.color);
      r.setAttribute('stroke-width', '2');
      r.style.opacity = '1';
      g.setAttribute('stroke', n.color);
      g.setAttribute('stroke-width', '2');
      g.setAttribute('opacity', '0.5');
      g.style.animation = 'nodePulse 1.8s ease-in-out infinite';
    });

    // --- Reset opacity for non-dimmed ---
    STAGES.forEach(function(n) {
      if (!(s.dimmed || []).includes(n.id)) {
        if (!(s.failed || []).includes(n.id) || (s.activeNodes || []).includes(n.id)) {
          // keep normal opacity unless dimmed
        }
      }
    });

    // --- Badges ---
    Object.entries(s.badges || {}).forEach(function(entry) {
      var nid = entry[0], cfg = entry[1];
      var bG   = document.getElementById('badge-' + nid);
      var bR   = document.getElementById('bRect-' + nid);
      var bT   = document.getElementById('bTxt-' + nid);
      var node = nodeMap[nid];
      var st   = BADGE_STYLES[cfg.style] || BADGE_STYLES.red;

      bG.style.display = '';
      bT.textContent = cfg.text;

      var w = cfg.text.length * 6.5 + 16;
      bR.setAttribute('width', w);
      bR.setAttribute('fill', st.bg);
      bR.setAttribute('stroke', st.border);
      bR.setAttribute('stroke-width', '1');
      bT.setAttribute('x', '8');

      var bx = node.x + NW - w + 10;
      var by = node.y - 10;
      bG.setAttribute('transform', 'translate(' + bx + ',' + by + ')');
    });

    // --- Build active edge ids ---
    var activeEdgeIds = (s.activeEdges || []).map(function(pair) {
      return getEdge(pair[0], pair[1]);
    });

    // --- Highlight active edges ---
    activeEdgeIds.forEach(function(eid) {
      var e = edgeMap[eid];
      if (!e) return;
      e.el.setAttribute('stroke', '#475569');
      e.el.setAttribute('stroke-width', '2.5');
      e.el.setAttribute('stroke-dasharray', '8,4');
      e.el.setAttribute('marker-end', 'url(#arr-hi)');
    });

    // --- Animated dots ---
    clearDots();
    activeEdgeIds.forEach(function(eid) {
      var color = s.dotColor || '#22c55e';
      var spd   = 0.9 / (speed() / 1000);
      dotAnims.push({ edgeId: eid, t: 0, speed: spd, color: color, trail: [] });

      // main dot
      var c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      c.setAttribute('r', '5');
      c.setAttribute('fill', color);
      c.setAttribute('filter', 'url(#dotGlow)');
      c.setAttribute('id', 'dot-' + eid);
      dotsG.appendChild(c);

      // trail dots (3 smaller trailing)
      for (var ti = 0; ti < 3; ti++) {
        var tc = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        tc.setAttribute('r', String(3.5 - ti * 0.8));
        tc.setAttribute('fill', color);
        tc.setAttribute('opacity', String(0.5 - ti * 0.15));
        tc.setAttribute('id', 'trail-' + eid + '-' + ti);
        dotsG.appendChild(tc);
      }
    });

    // --- Info panel ---
    document.getElementById('stepLabel').textContent = 'Step ' + (idx + 1) + ' of ' + STEPS.length;
    document.getElementById('stepTitle').textContent = s.name;
    document.getElementById('stepDesc').innerHTML = s.desc;
    document.getElementById('stepCounter').textContent = (idx + 1) + ' / ' + STEPS.length;

    // --- Info panel border tint ---
    var panel = document.getElementById('infoPanel');
    if (s.isError) panel.style.borderColor = '#ef444488';
    else if (s.isEnd) panel.style.borderColor = '#22c55e88';
    else panel.style.borderColor = '#334155';

    // --- Step title color ---
    var titleEl = document.getElementById('stepTitle');
    if (s.isError) titleEl.style.color = '#fca5a5';
    else if (s.isEnd) titleEl.style.color = '#4ade80';
    else titleEl.style.color = '#f1f5f9';

    // --- Progress pips ---
    for (var i = 0; i < pips.length; i++) {
      pips[i].className = 'progress-pip' +
        (i < idx ? ' done' : '') +
        (i === idx ? ' active done' : '');
    }

    // --- Button state ---
    document.getElementById('btnPrev').disabled = idx === 0;
    document.getElementById('btnNext').disabled = idx === STEPS.length - 1;
  }

  function clearDots() {
    while (dotsG.firstChild) dotsG.removeChild(dotsG.firstChild);
    dotAnims = [];
  }

  // ==============================================================
  //  ANIMATION LOOP (requestAnimationFrame)
  // ==============================================================
  var lastT = 0;

  function tick(ts) {
    var dt = Math.min((ts - lastT) / 1000, 0.1);
    lastT = ts;

    dotAnims.forEach(function(da) {
      var edge = edgeMap[da.edgeId];
      if (!edge) return;

      da.t += dt * da.speed;
      if (da.t > 1) da.t -= 1;

      var pt = edge.el.getPointAtLength(da.t * edge.len);
      var dot = document.getElementById('dot-' + da.edgeId);
      if (dot) {
        dot.setAttribute('cx', pt.x);
        dot.setAttribute('cy', pt.y);
      }

      // trailing dots at earlier t values
      for (var ti = 0; ti < 3; ti++) {
        var trailT = da.t - (ti + 1) * 0.06;
        var tt = trailT < 0 ? trailT + 1 : trailT;
        var tp = edge.el.getPointAtLength(tt * edge.len);
        var te = document.getElementById('trail-' + da.edgeId + '-' + ti);
        if (te) {
          te.setAttribute('cx', tp.x);
          te.setAttribute('cy', tp.y);
        }
      }
    });

    // Pulse glow rects (use sine wave)
    var pulse = 0.3 + 0.7 * Math.abs(Math.sin(ts / 600));
    var step = STEPS[currentStep];
    if (step) {
      (step.activeNodes || []).forEach(function(nid) {
        var g = document.getElementById('glow-' + nid);
        if (g) g.setAttribute('opacity', String(pulse * 0.5));
      });
    }

    rafId = requestAnimationFrame(tick);
  }

  // ==============================================================
  //  PLAYBACK CONTROLS
  // ==============================================================
  function scheduleNext() {
    clearTimeout(timer);
    if (!playing) return;
    var dur = STEPS[currentStep] ? STEPS[currentStep].duration : 2000;
    // Scale duration based on speed selection
    var ratio = speed() / 3200;
    timer = setTimeout(function() {
      if (currentStep < STEPS.length - 1) {
        currentStep++;
      } else {
        currentStep = 0;
      }
      applyStep(currentStep);
      scheduleNext();
    }, dur * ratio);
  }

  function goToStep(idx) {
    clearTimeout(timer);
    currentStep = Math.max(0, Math.min(STEPS.length - 1, idx));
    applyStep(currentStep);
    if (playing) scheduleNext();
  }

  document.getElementById('btnPrev').addEventListener('click', function() { goToStep(currentStep - 1); });
  document.getElementById('btnNext').addEventListener('click', function() { goToStep(currentStep + 1); });

  document.getElementById('btnPlay').addEventListener('click', function() {
    playing = !playing;
    var btn = document.getElementById('btnPlay');
    btn.textContent = playing ? 'Pause' : 'Play';
    btn.classList.toggle('primary', playing);
    if (playing) scheduleNext();
    else clearTimeout(timer);
  });

  document.getElementById('speedSelect').addEventListener('change', function() {
    if (playing) {
      clearTimeout(timer);
      scheduleNext();
    }
  });

  // Keyboard controls
  document.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') { e.preventDefault(); goToStep(currentStep - 1); }
    if (e.key === 'ArrowRight' || e.key === 'ArrowDown') { e.preventDefault(); goToStep(currentStep + 1); }
    if (e.key === ' ') {
      e.preventDefault();
      document.getElementById('btnPlay').click();
    }
  });

  // ==============================================================
  //  INIT
  // ==============================================================
  currentStep = 0;
  applyStep(0);
  lastT = performance.now();
  rafId = requestAnimationFrame(tick);
  scheduleNext();

})();
</script>
</body>
</html>
